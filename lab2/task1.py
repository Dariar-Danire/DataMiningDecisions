# Задача 1:
# Поступающий на работу плиточник заявляет, что за час выкладывает 4 кв. м. плитки.
# Мастер считает, что только 3 кв.м. Через какое количество часов работы можно определить
# с вероятностью 95% кто из них прав? Какова будет при этом мощность проверки?

# УЗ =  5%
# Нулевая гипотеза  p0: плиточник кладёт 4 кв.м. плитки / час
# Альтернативная    pa:   плиточник кладёт 3 кв.м. плитки / час

# УЗ = 5%

# Выразим данные в статистической формулировке при условии, что самый лучший плиточник выкладывает 8 кв м / ч плитки.
# Мы получим следующие данные: p_0 = 4 / 8 = 1 / 2,     p_a = 3 / 8.
# Поскольку речь идёт о постоянной величине (плиточник всегда выкладывает столько-то), статистика выкладки плитки
# должна подчиняться нормальному распределению. Параметры распределения можно вычислить, если учесть, что исходов
# может быть только 2: выложил за час 4 кв м плитки (1) или выложил меньше (0). Получается, можно действовать по схеме Бернулли.
# Тогда мы вычисляем: ro_0, ro_a, mu_0, mu_a, sigma_0, sigma_а (sqrt(npq) которая). Предварительно определяем
# величину выборки n (для начала можно взять 100) (её точное значение, кстати, и искать будем).
# Допустимая область значений для принятия гипотезы: плиточник выкладывает от (4 - sigma_0) до (4 + sigma_0) плитки.

import math

def solve(x):
    for n in range(100, 10000):
        if testing(x, n):
            break

#
def testing(x, n):
    # Определяем уровень значимости alpha и x (количество неудачных исходов для текущего n)
    alpha = 0.05
    x = x / (8 * n) * 100

    # Определяем p_0 и p_a: нулевую и альтернативную гипотезы
    p_0 = 4 / 8

    # Вероятность обратного события
    q_0 = 1 - p_0

    # Среднее отклонение для p_0
    mu_0 = n * p_0

    # Находим стандартное отклонение
    sigma_0 = math.sqrt(p_0 * q_0 * n)

    # Вычисляем верхнюю и нижнюю грницы
    s_low = inv_f_norm(alpha / 2, mu_0, sigma_0)
    s_hight = 2 * mu_0 - s_low

    # Вычисляем мощность проверки
    w = 1 - rho_norm(x, mu_0, sigma_0)

    if s_low <= x <= s_hight or p_value(x, mu_0, sigma_0) > alpha:
        print("\nМощность проверки w =", w, ".")
        print("Потребовалось", n, "часов.")
        return True


# Нормальное распределение - плотность вероятности
def rho_norm(x, mu=0, s=1):
    return 1/math.sqrt(2*math.pi*s) *math.exp(-(x-mu) **2/2/s**2)

# Нормальное распределение - функция распределения
def f_norm(x, mu=0, s=1):
    return(1+math.erf((x-mu)/math.sqrt(2)/s))/2

# p-значение (вероятность ошибки первого рода)
def p_value(x, mu=0, s=1):
    if x >=mu:
        return 2*(1-f_norm(x, mu, s))
    else:
        return 2*f_norm(x, mu, s)

# Обратная функция нормального распределения в полосе значений -100...100
# t - точность
def inv_f_norm(p, mu, s, t=0.001):
    # Сначала перейдём к стандартному распределению
    if mu != 0 or s != 1:
        return mu + s * inv_f_norm(p,0,1,t)

    # Ищем в полосе значений -100...100
    low_x, low_p = -100.0, 0
    hi_x, hi_p = 100.0, 1

    while hi_x - low_x > t:
        mid_x = (low_x + hi_x)/2
        mid_p = f_norm(mid_x)
        if mid_p < p:
            low_x, low_p = mid_x, mid_p
        elif mid_p > p:
            hi_x, hi_p = mid_x, mid_p
        else:
            break

    return mid_x